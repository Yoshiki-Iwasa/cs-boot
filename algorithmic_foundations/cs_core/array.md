# Arrays (Dynamic)
参考
- https://www.geeksforgeeks.org/what-is-array/
- https://doc.rust-lang.org/std/primitive.array.html
- https://en.wikipedia.org/wiki/Array_(data_structure)
- https://en.wikipedia.org/wiki/Dynamic_array


## explain its definition, properties, representation(s), and associated ADT operations.
- **Definition**: 動的配列は、要素が追加されるときにサイズを自動的に調整する配列。固定長の配列を基にしており、必要に応じて拡大する。
- **Properties**: 要素は配列の連続したメモリ位置に格納される。配列のサイズ（論理サイズ）と容量（物理サイズ）は異なり、容量は現在の要素数よりも大きく設定されることが多い。
- **Representations**: 配列の実装は、一般的には基礎となる固定サイズの配列と、その上に構築される。
- **Associated ADT operations**: `insert`, `delete`, `resize` などの操作が含まれる。`insert` は要素を追加し、必要に応じて配列をリサイズする。`delete` は要素を削除し、配列のサイズは変更しない。

## explain step-by-step how the ADT operations associated with the data structure transform it.
- **Insertion**: 要素を追加する際、まず配列の末尾に要素を置く。空きスペースがない場合、配列を新しい、より大きな配列に拡張してから要素を追加する。
  1. 要素を追加する位置を決定（通常は末尾）。
  2. 配列に空きがあればその位置に要素を置く。
  3. 空きがなければ配列のサイズを拡大し、全要素を新しい配列にコピー後、新しい要素を追加する。
  4. insert-middleやinsert-frontはO(N)かかる
- **Deletion**: 要素を配列から削除するときは、特定の位置の要素を削除し、後続の要素を前にシフトする。
  1. 削除する要素の位置を特定。
  2. その要素を削除し、必要に応じて後続の要素を前にシフトさせる。
  3. 配列の論理サイズを更新する。
- **Resizing**: 配列が拡大する際は、新しい、大きな配列が確保され、既存の要素が新しい配列にコピーされる。
  1. 新しい配列のサイズを決定（通常は現在のサイズの2倍など）。
  2. 新しい配列を割り当てる。
  3. 既存の配列から新しい配列に全要素をコピーする。

# 講義ノート
primitiveな配列と分けるためにvectorって名前つけたりするよ

capacity: 確保してるメモリ空間を表している
いっぱいになったら2倍(doubling)する。コピー操作には要素分の操作が必要な高コスト操作
amortized computation cost. 慣らすと定数時間で終わる。
### 償却コストの数学的背景

動的配列の要素追加における償却コストの計算を数学的に説明します。

#### 動的配列の倍増

動的配列がいっぱいになると、そのサイズを倍にして新しい配列を作成し、古い配列の要素を新しい配列にコピーします。この操作のコストを評価します。

1. **初期状態**:
   配列のサイズを1とします。このとき、配列に要素を追加するコストは `O(1)` です。

2. **配列がいっぱいになったとき**:
   配列のサイズを倍にし、要素をコピーします。このコピー操作のコストは現在の配列の要素数 `N` に比例し、 `O(N)` です。

#### 償却コストの計算

償却コストを計算するために、配列のサイズが倍増する過程を段階的に見ていきます。

1. 配列サイズが1から2に増加する際のコピーコスト: `1` (1要素コピー)
2. 配列サイズが2から4に増加する際のコピーコスト: `2` (2要素コピー)
3. 配列サイズが4から8に増加する際のコピーコスト: `4` (4要素コピー)
4. このパターンが続く

これを一般化すると、配列サイズが `2^k` から `2^(k+1)` に増加する際のコピーコストは `2^k` となります。

次に、要素を `N` 個追加する際の総コピーコストを計算します。

#### 総コピーコスト

要素を `N` 個追加する際の総コピーコストは次のようになります。

$$
\[
\text{総コピーコスト} = 1 + 2 + 4 + 8 + \dots + 2^{k-1}
\]
$$

ここで、 `2^{k-1}` は最大で `N` に等しいため、以下の等比数列の和を求めます。

$$
\[
\text{総コピーコスト} = 2^0 + 2^1 + 2^2 + \dots + 2^{k-1}
\]
$$

等比数列の和の公式を用いると、

$$
\[
\sum_{i=0}^{k-1} 2^i = 2^k - 1
\]
$$

ここで、 `2^k` は `N` より大きくないので、

$$
\[
2^k \approx N \implies \sum_{i=0}^{k-1} 2^i = 2^k - 1 \leq 2N - 1
\]
$$
したがって、総コピーコストは最大で `2N - 1` です。

#### 償却コスト

要素を `N` 個追加する際の総操作回数は `N` です。したがって、平均コスト（償却コスト）は次のように計算されます。

$$
\[
\text{償却コスト} = \frac{\text{総コピーコスト}}{N} \leq \frac{2N - 1}{N} \approx 2
\]
$$

したがって、償却コストは定数時間 `O(1)` になります。

### 結論

動的配列の要素追加における償却コストは `O(1)` です。これは、配列サイズを倍増する操作がまれに高コストであっても、全体としては一定時間で処理されることを意味します。

# 多次元配列のメモリレイアウト
https://qiita.com/tyoshitake/items/83ce47f169c5b037f06c

- Row-major order, Column-major order
メモリ一列で並べる。固定長多次元配列ならできる

- Iliffe vector
他の配列の先頭ポインタをもっていく
