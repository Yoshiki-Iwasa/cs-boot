# Title

# Illustrative Learning Outcomes

## Prepare a presentation that explains to first year students the basic concepts of algorithmic complexity including best, average, and worst-case algorithm behavior, Big- O, Omega, and Theta notations, complexity classes, time and space tradeoffs, empirical measurement, and impact on practical problems.

## Using examples, explain each of the foundational complexity classes in this unit.


## For each foundational complexity class in this unit, explain an algorithm that demonstrates the associated runtime complexity.

## For each algorithm in the AL-Foundational unit, explain its runtime complexity class and why it belongs to this class.

## Informally evaluate the foundational complexity class of simple algorithms.

## Given a problem to program for which there may be several algorithmic approaches, evaluate them and determine which are feasible, and select one that is optimal in implementation and run-time behavior.

## Develop empirical studies to determine and validate hypotheses about the runtime complexity of various algorithms by running algorithms on input of various sizes and comparing actual performance to the theoretical analysis.


## Explain examples that illustrate time-space tradeoffs of algorithms.

## Explain how tree balance affects the efficiency of binary search tree operations.

## Explain to a non-technical audience the significance of tractable versus intractable algorithms using an intuitive explanation of Big-O complexity.


## Explain the significance of NP-Completeness.

## Explain how NP-Hard is a lower bound and NP is an upper bound for NP-Completeness.

## Explain examples of NP-complete problems.
